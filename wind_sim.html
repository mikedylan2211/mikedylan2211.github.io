<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Improved Global Wind Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; font-family: Inter, Arial, sans-serif; background: #000; overflow: hidden; }
    canvas { display:block; }
    #ui {
      position: absolute; left: 12px; top: 12px;
      background: rgba(0,0,0,0.7); color: #fff; padding: 12px; border-radius: 10px;
      min-width: 220px; z-index: 50; font-size: 13px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    }
    #loading {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.8); padding: 18px; border-radius: 10px; color: #fff; z-index: 60;
    }
    .slider-container { margin-top: 8px; }
    input[type="range"] { width: 100%; }
    button { width: 100%; margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.08); color: #fff; border: 1px solid rgba(255,255,255,0.06); border-radius: 6px; cursor: pointer; }
    button:hover { background: rgba(255,255,255,0.12); }
    small { opacity: 0.85; font-size: 11px; display:block; margin-top:6px; }
  </style>
</head>
<body>
  <div id="ui">
    <strong>Global Wind Visualization</strong>
    <div id="altitudeInfo" style="font-size:12px; opacity:0.9; margin-top:6px;">Surface winds (10 m)</div>
    <div style="margin-top:8px;">Hover: <span id="windSpeed">-</span> m/s</div>
    <div>Position: <span id="position">-</span></div>
    <div class="slider-container">
      <label>Animation speed: <span id="speedValue">1.0</span>x</label>
      <input id="speedSlider" type="range" min="0.1" max="3" step="0.1" value="1.0" />
    </div>
    <button id="updateData">Regenerate wind field</button>
    <small id="dataInfo">Synthetic sample data</small>
  </div>

  <div id="loading">Loading assets and generating wind dataâ€¦</div>

  <!-- Three.js r128 and OrbitControls (non-module) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  // CONFIG
  const CONFIG = {
    earthRadius: 5,
    arrowBaseLength: 0.35,    // length for moderate wind
    arrowMaxLength: 1.4,      // max length for very strong winds
    maxWindSpeed: 40,         // used to normalize color & length
    gridSpacingDeg: 3,        // degrees between sample points
    minDisplaySpeed: 0.6      // threshold to show an arrow (m/s)
  };

  // State
  let currentSpeed = 1.0;
  let windData = [];
  let windArrows = [];
  let materialCache = new Map();

  // Scene / renderer
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 8, 16);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.minDistance = 7;
  controls.maxDistance = 45;

  // Lights
  scene.add(new THREE.HemisphereLight(0xbfeaff, 0x202020, 0.9));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(10, 8, 5);
  scene.add(dir);

  // Earth group
  const earthGroup = new THREE.Group();
  scene.add(earthGroup);

  // Load textures (color + stars)
  const loader = new THREE.TextureLoader();
  const earthTextureURL = 'https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg';
  const nightTextureURL = 'https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-night.jpg';
  const starfieldURL = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/cube/Bridge2/px.jpg'; // fallback - will be used as single quad if cube not available

  // Earth mesh
  const earthGeo = new THREE.SphereGeometry(CONFIG.earthRadius, 64, 64);
  const earthMat = new THREE.MeshPhongMaterial({ shininess: 8 });

  // Atmosphere (simple glow)
  const atmosphereGeo = new THREE.SphereGeometry(CONFIG.earthRadius * 1.02, 48, 48);
  const atmosphereMat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.06, side: THREE.BackSide });
  const atmosphere = new THREE.Mesh(atmosphereGeo, atmosphereMat);
  earthGroup.add(atmosphere);

  const earthMesh = new THREE.Mesh(earthGeo, earthMat);
  earthGroup.add(earthMesh);

  // Starfield background (large sphere)
  const starsGeo = new THREE.SphereGeometry(200, 32, 32);
  const starsMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });
  const starsMesh = new THREE.Mesh(starsGeo, starsMat);
  scene.add(starsMesh);

  // Arrow template pieces (shared geometry)
  const shaftGeo = new THREE.CylinderGeometry(0.02, 0.02, 1.0, 8, 1, true);
  shaftGeo.translate(0, -0.5, 0); // so cylinder extends along -Y by default
  const coneGeo = new THREE.ConeGeometry(0.06, 0.20, 8);
  coneGeo.translate(0, -1.06, 0); // tip at -1.16
  // We'll build a Group with shaft+cone and then orient/scale it.

  // helper: lat/lon to 3D position on sphere
  function latLonToVector3(lat, lon, radius) {
    const phi = (90 - lat) * Math.PI/180;
    const theta = (lon + 180) * Math.PI/180;
    return new THREE.Vector3(
      -radius * Math.sin(phi) * Math.cos(theta),
      radius * Math.cos(phi),
      radius * Math.sin(phi) * Math.sin(theta)
    );
  }

  // color map by speed (smooth interpolation)
  function getColorForWindSpeed(speed) {
    const t = Math.min(speed / CONFIG.maxWindSpeed, 1);
    // gradient from blue -> cyan -> green -> yellow -> red
    if (t < 0.25) {
      // blue -> cyan
      const s = t/0.25;
      return new THREE.Color().lerpColors(new THREE.Color(0x2f59ff), new THREE.Color(0x00d3d3), s);
    } else if (t < 0.5) {
      const s = (t-0.25)/0.25;
      return new THREE.Color().lerpColors(new THREE.Color(0x00d3d3), new THREE.Color(0x2fe64a), s);
    } else if (t < 0.75) {
      const s = (t-0.5)/0.25;
      return new THREE.Color().lerpColors(new THREE.Color(0x2fe64a), new THREE.Color(0xffd133), s);
    } else {
      const s = (t-0.75)/0.25;
      return new THREE.Color().lerpColors(new THREE.Color(0xffd133), new THREE.Color(0xff4d27), s);
    }
  }

  // material cache for colors to avoid many unique materials
  function getMaterialForColor(color) {
    const key = color.getHexString();
    if (materialCache.has(key)) return materialCache.get(key);
    const mat = new THREE.MeshPhongMaterial({ color: color, shininess: 10 });
    materialCache.set(key, mat);
    return mat;
  }

  // Create arrow Group oriented along -Y in local space (shaft+cone); we'll rotate later.
  function buildArrowMesh(color) {
    const group = new THREE.Group();
    // Use cached material for color
    const mat = getMaterialForColor(color);
    const shaft = new THREE.Mesh(shaftGeo, mat);
    const cone = new THREE.Mesh(coneGeo, mat);
    group.add(shaft);
    group.add(cone);
    // By construction cone tip points further along -Y; we'll treat -Y as "forward"
    return group;
  }

  // Create an arrow physically placed on the globe, oriented tangent to surface and pointing in wind direction
  function createWindArrow(lat, lon, u, v) {
    const speed = Math.sqrt(u*u + v*v);
    if (speed < CONFIG.minDisplaySpeed) return null;

    // position just above surface
    const pos = latLonToVector3(lat, lon, CONFIG.earthRadius * 1.01);
    const radial = pos.clone().normalize();

    // Tangent east/north basis
    const northPole = new THREE.Vector3(0,1,0);
    // east = northPole cross radial
    let east = new THREE.Vector3().crossVectors(northPole, radial);
    if (east.lengthSq() < 1e-6) {
      // at pole, pick arbitrary east
      east = new THREE.Vector3(1, 0, 0);
    } else {
      east.normalize();
    }
    const north = new THREE.Vector3().crossVectors(radial, east).normalize();

    // Wind vector in tangent plane: u = eastward, v = northward
    const windVec = new THREE.Vector3()
      .addScaledVector(east, u)
      .addScaledVector(north, v);

    const windLen = windVec.length();
    if (windLen < 1e-6) return null;
    windVec.normalize();

    // Create arrow (group) with color
    const color = getColorForWindSpeed(speed);
    const arrow = buildArrowMesh(color);

    // Place arrow so its origin sits on the surface (we built arrow pointing along -Y)
    // We'll orient -Y to point along windVec tangent. So compute quaternion from -Y to windVec.
    const localForward = new THREE.Vector3(0, -1, 0); // our arrow forward
    const q = new THREE.Quaternion().setFromUnitVectors(localForward, windVec);
    // But arrow also needs to be rotated to align with the local tangent plane orientation -> apply to arrow directly.
    arrow.quaternion.copy(q);

    // Place arrow so its base sits slightly above the surface along the radial
    const lift = 0.04 + 0.02 * Math.log10(1 + speed);
    const placePos = pos.clone().addScaledVector(radial, lift);
    arrow.position.copy(placePos);

    // Then rotate arrow so it's tangent (we've oriented forward along windVec) but also align with surface local normal
    // (we already used windVec which is tangent, so good)

    // Scale arrow length according to wind speed
    const t = Math.min(speed / CONFIG.maxWindSpeed, 1);
    const length = CONFIG.arrowBaseLength + (CONFIG.arrowMaxLength - CONFIG.arrowBaseLength) * t;
    arrow.scale.set(1, length, 1); // shaft is along -Y, so scale.y lengthens tip-to-tail

    // store metadata for hover + animation
    arrow.userData = {
      lat, lon, u, v, speed, baseScaleY: length
    };

    return arrow;
  }

  // Clear arrows
  function clearWindArrows() {
    windArrows.forEach(a => {
      // dispose? geometries are shared; materials are cached. Just remove from group.
      if (a.parent) a.parent.remove(a);
    });
    windArrows = [];
  }

  // Generate a smoother, more realistic synthetic wind field
  function generateWindField() {
    const points = [];
    const spacing = CONFIG.gridSpacingDeg;
    // We'll generate smooth fields by combining:
    //  - latitude-dependent base flows (Hadley, Westerlies, Polar)
    //  - planetary-scale Rossby-like sinusoidal waves
    //  - regional monsoons
    //  - localized cyclonic perturbations (storms)
    //  - small-scale turbulence added as low-frequency sinusoids (pseudo-noise)
    const rng = (seed => () => {
      // simple LCG for repeatable randomness
      seed = (seed * 1664525 + 1013904223) >>> 0;
      return (seed & 0xFFFFFF) / 0x1000000;
    })(Math.floor(Math.random()*1e9));

    // create a small set of random storm centers
    const storms = [];
    for (let i=0;i<6;i++) {
      storms.push({
        lat: (rng()*160)-80,
        lon: (rng()*360)-180,
        intensity: 8 + rng()*18,
        radiusDeg: 5 + rng()*18
      });
    }

    for (let lat = -84; lat <= 84; lat += spacing) {
      for (let lon = -180; lon < 180; lon += spacing) {
        const latRad = lat * Math.PI/180;
        const lonRad = lon * Math.PI/180;

        // Base zonal (east-west) flows
        let u = 0, v = 0;

        // Hadley (0-30): easterlies toward west->east? Trade winds generally east->west (u negative in NH? careful).
        // We'll create realistic pattern: near equator easterly (westward) trades in equator belts.
        const absLat = Math.abs(lat);

        if (absLat < 30) {
          // trade winds: blow toward the equator and westward
          const tradeStrength = 6 + 4 * Math.cos(latRad) * (0.7 + 0.3*Math.random());
          // westward component (negative u)
          u += -tradeStrength * (0.6 + 0.4 * Math.sin(lonRad*1.5));
          // weak meridional component toward equator
          v += -Math.sign(lat) * (1.2 + Math.random()*0.8);
          // doldrums reduction near equator
          if (absLat < 8) {
            const factor = absLat/8;
            u *= (0.25 + 0.75 * factor);
            v *= (0.25 + 0.75 * factor);
            // more variability
            u += (Math.random()-0.5) * 3;
            v += (Math.random()-0.5) * 3;
          }
        } else if (absLat < 60) {
          // Westerlies: predominantly eastward (positive u)
          const westStrength = 9 + 5 * Math.cos(latRad);
          u += westStrength * (0.6 + 0.4*Math.cos(lonRad*0.7));
          // slight poleward component
          v += (lat > 0 ? 0.8 : -0.8) * (0.4 + Math.random()*0.6);
          // jet enhancement band
          if ((lat > 35 && lat < 55) || (lat < -35 && lat > -55)) {
            u *= (1.1 + Math.random()*0.4);
          }
        } else {
          // polar easterlies: weaker, generally east-to-west relative
          const polar = 3 + 3*Math.random();
          u += -polar * (0.4 + 0.6*Math.cos(lonRad));
          v += (lat > 0 ? -1 : 1) * (0.5 + Math.random()*0.7);
        }

        // Rossby-like planetary waves
        u += 2.5 * Math.sin(2*lonRad + 0.6*latRad);
        v += 1.8 * Math.cos(1.5*lonRad - 0.3*latRad);

        // Seasonal monsoon-ish enhancements (synthetic)
        if (lon >= 60 && lon <= 120 && lat >= 5 && lat <= 30) {
          // Indian monsoon add southwesterly in summer (approximate)
          const seasonFactor = 1.0; // could be set by UI later
          u += -5 * Math.cos(latRad) * seasonFactor;
          v += 3 * Math.sin(latRad) * seasonFactor;
        }
        if (lon >= 100 && lon <= 150 && lat >= 20 && lat <= 45) {
          u += -3 * Math.cos(latRad);
          v += 2 * Math.sin(latRad);
        }

        // Ocean equatorial current influence
        if (Math.abs(lat) < 12) {
          u += 1.2 * Math.sin(lonRad*2.5);
        }

        // Add storms' perturbations (cyclonic swirl)
        storms.forEach(s => {
          const dlat = lat - s.lat;
          const dlon = Math.abs((lon - s.lon + 180 + 360) % 360 - 180); // wrap diff
          const dist = Math.sqrt(dlat*dlat + dlon*dlon);
          if (dist < s.radiusDeg*2) {
            const strength = s.intensity * Math.exp(- (dist*dist) / (2*(s.radiusDeg*s.radiusDeg)));
            // swirl: perpendicular to radial vector from storm center
            const angleToCenter = Math.atan2(lat - s.lat, (lon - s.lon));
            u += -strength * Math.sin(angleToCenter);
            v +=  strength * Math.cos(angleToCenter);
          }
        });

        // low-frequency pseudo-noise: layered sinusoids for texture
        u += 1.2 * Math.sin(0.9*lonRad + 0.5*latRad) + 0.6 * Math.sin(2.8*lonRad + 1.9*latRad);
        v += 0.9 * Math.cos(1.7*lonRad - 0.4*latRad) + 0.5 * Math.cos(3.3*lonRad + 0.7*latRad);

        // small random jitter
        u += (Math.random()-0.5) * 1.2;
        v += (Math.random()-0.5) * 1.2;

        // clamp strong winds
        const speed = Math.sqrt(u*u + v*v);
        const max = 45;
        if (speed > max) {
          u *= max / speed;
          v *= max / speed;
        }

        points.push({ lat, lon, u, v, speed: Math.sqrt(u*u + v*v) });
      }
    }

    return points;
  }

  // Update visualization from windData
  function updateWindVisualization() {
    clearWindArrows();
    if (!Array.isArray(windData) || windData.length === 0) return;

    let created = 0;
    const arrowsParent = new THREE.Group();
    earthGroup.add(arrowsParent);

    for (const p of windData) {
      const arrow = createWindArrow(p.lat, p.lon, p.u, p.v);
      if (arrow) {
        arrowsParent.add(arrow);
        windArrows.push(arrow);
        created++;
      }
    }
    document.getElementById('altitudeInfo').textContent = `Surface winds (10 m) â€” ${created.toLocaleString()} arrows`;
  }

  // Load textures and data, then hide loading overlay
  function initialize() {
    const loadingEl = document.getElementById('loading');
    loadingEl.style.display = 'block';

    // Load textures in parallel (earth color + night + star)
    const texPromises = [
      new Promise(res => loader.load(earthTextureURL, img => res({ name: 'color', img }), undefined, () => res(null))),
      new Promise(res => loader.load(nightTextureURL, img => res({ name: 'night', img }), undefined, () => res(null))),
      new Promise(res => loader.load(starfieldURL, img => res({ name: 'stars', img }), undefined, () => res(null)))
    ];

    Promise.all(texPromises).then(results => {
      // apply earth texture if loaded
      const colorTex = results.find(r => r && r.name === 'color')?.img;
      const nightTex = results.find(r => r && r.name === 'night')?.img;
      const starTex = results.find(r => r && r.name === 'stars')?.img;

      if (colorTex) earthMat.map = colorTex;
      if (nightTex) {
        // blend night texture as emissiveMap so nights glow
        earthMat.emissiveMap = nightTex;
        earthMat.emissiveIntensity = 0.4;
      }
      earthMat.needsUpdate = true;

      if (starTex) {
        starsMat.map = starTex;
        starsMat.needsUpdate = true;
      }
    }).finally(() => {
      // generate data, with slight timeout to show spinner for realism
      setTimeout(() => {
        windData = generateWindField();
        updateWindVisualization();
        document.getElementById('loading').style.display = 'none';
      }, 350);
    });
  }

  // Animation pulse for arrows
  function animateWinds(speedMultiplier = 1.0) {
    const t = Date.now() * 0.001 * speedMultiplier;
    for (const arrow of windArrows) {
      const base = arrow.userData.baseScaleY || 1.0;
      // subtle pulsation based on speed and position
      const pulse = 0.9 + 0.18 * Math.sin(t * 2 + arrow.userData.speed * 0.14 + (arrow.userData.lat + arrow.userData.lon)*0.02);
      arrow.scale.y = base * pulse;
    }
  }

  // Raycaster hover
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let lastHover = null;

  function onMouseMove(e) {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  }
  window.addEventListener('mousemove', onMouseMove, { passive: true });

  // Update loop
  function animate() {
    requestAnimationFrame(animate);
    controls.update();

    // Earth rotation
    earthGroup.rotation.y += 0.00035;

    // animate arrows
    animateWinds(currentSpeed);

    // hover detection (throttle by frames via early return if no arrows)
    if (windArrows.length > 0) {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(windArrows, true);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        // find top-level arrow group
        let arrowTop = obj;
        while (arrowTop && !arrowTop.userData.lat && arrowTop.parent) {
          arrowTop = arrowTop.parent;
        }
        // have valid arrowTop
        if (arrowTop && arrowTop.userData && arrowTop.userData.speed !== undefined) {
          if (lastHover !== arrowTop) {
            // reset previous
            if (lastHover) {
              // remove highlight by restoring material (materials are shared cached objects)
              lastHover.traverse((m) => {
                if (m.isMesh) m.material.emissiveIntensity = 0;
              });
            }
            lastHover = arrowTop;
            // highlight
            arrowTop.traverse((m) => {
              if (m.isMesh) m.material.emissive = new THREE.Color(0x222222);
            });
          }
          document.getElementById('windSpeed').textContent = arrowTop.userData.speed.toFixed(1);
          document.getElementById('position').textContent = `Lat: ${arrowTop.userData.lat.toFixed(1)}Â°, Lon: ${arrowTop.userData.lon.toFixed(1)}Â°`;
        }
      } else {
        if (lastHover) {
          lastHover.traverse((m) => { if (m.isMesh) m.material.emissive = new THREE.Color(0x000000); });
          lastHover = null;
        }
        document.getElementById('windSpeed').textContent = '-';
        document.getElementById('position').textContent = '-';
      }
    }

    renderer.render(scene, camera);
  }

  // UI wiring
  document.getElementById('speedSlider').addEventListener('input', (e) => {
    currentSpeed = parseFloat(e.target.value);
    document.getElementById('speedValue').textContent = currentSpeed.toFixed(1);
  });

  document.getElementById('updateData').addEventListener('click', () => {
    document.getElementById('loading').style.display = 'block';
    setTimeout(() => {
      windData = generateWindField();
      updateWindVisualization();
      document.getElementById('loading').style.display = 'none';
    }, 240);
  });

  // handle resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Start
  initialize();
  animate();

  </script>
</body>
</html>
